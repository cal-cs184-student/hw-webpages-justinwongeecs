<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			html {
				scroll-behavior: smooth;
			}

			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 40px;
				max-width: 900px;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
				margin: 0;
			}

			.page {
				display: flex;
				align-items: flex-start;
				gap: 24px;
			}

			.sidebar {
				position: sticky;
				top: 24px;
				width: 280px;
				max-height: calc(100vh - 48px);
				overflow: auto;
				padding: 20px;
				border-right: 1px solid #e6e6e6;
			}

			.sidebar h3 {
				margin: 0 0 12px 0;
				font-size: 16px;
			}

			.sidebar ul {
				list-style: none;
				margin: 0;
				padding: 0;
			}

			.sidebar li {
				margin: 0 0 10px 0;
			}

			ul > li,
			ol > li {
				margin-bottom: 10px;
			}

			ul > li:last-child,
			ol > li:last-child {
				margin-bottom: 0;
			}

			.sidebar a {
				color: #0057A8;
				text-decoration: none;
				font-size: 0.98rem;
				font-weight: 400;
				transition: font-size 120ms ease, font-weight 120ms ease;
			}

			.sidebar a.active {
				font-weight: 700;
				font-size: 1.06rem;
			}

			.main-content {
				flex: 1;
				min-width: 0;
			}

			@media (max-width: 900px) {
				.page {
					flex-direction: column;
				}

				.sidebar {
					position: static;
					width: auto;
					max-height: none;
					border-right: none;
					border-bottom: 1px solid #e6e6e6;
					margin: 0 16px;
					padding: 16px 0;
				}

				.container {
					padding: 20px 16px 40px;
				}
			}

				@media print {
					/* Print engines often ignore page breaks inside flex layouts. */
					.page {
						display: block;
					}

					.sidebar {
						display: none;
					}

					.main-content,
					.container {
						display: block;
						max-width: none;
						width: auto;
					}

					.page-break {
						display: block;
						height: 0;
						break-before: page;
						page-break-before: always;
					}
				}
			</style>
		<script src="design-system.js"></script>
	</head>
	<body>
		<div class="page">
			<aside class="sidebar">
				<h3>Tasks</h3>
				<ul id="task-nav"></ul>
			</aside>
			<div class="main-content">
				<div class="container">
				<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
				<div style="text-align: center;">Names: Valerie He, Justin Wong</div>

				<br>

				Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-justinwongeecs/hw1/index.html">https://cal-cs184-student.github.io/hw-webpages-justinwongeecs/hw1/index.html</a>
				
				<br>

				Link to GitHub repository: <a href="https://github.com/cal-cs184-student/hw1-rasterizer-hello-world">https://github.com/cal-cs184-student/hw1-rasterizer-hello-world</a>

				<!--
				We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
				-->

				<h2>Overview</h2>
				Through these six tasks, we incrementally built a basic rasterizer that is able to draw triangles, antialias them, apply transforms for mutation, interpolate colors, and support pixel & level sampling with mipmaps. Through basic mathematical equations, we 
				were able to describe visually how colors can be created and mutated. Most of the math was related to triangles as they are the primative fundamental building blocks for graphics. At the crux of presenting different shapes on the screen, lies the problem of antialiasing. 
				We've explored three different antialiasing techniques: the number of samples per pixel, pixel sampling, and level sampling where each method has its own tradeoffs and benefits. It was particularly interesting working with the texture and screen worlds as it felt that we were building
				bridges between these different but yet seemingly similar realms.


				<!-- Task content is loaded from tasks/task1.html, task2.html, etc. -->
				<div id="tasks-container"></div>

				<!-- <h2>Additional Notes (please remove)</h2>
				<ul>
					<li>You can also add code if you'd like as so: <code>code code code</code></li>
					<li>If you'd like to add math equations, 
						<ul>
							<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
							<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
						</ul>
					</li>
				</ul> -->
				</div>
			</div>
		</div>

			<script>
				// Always start at top on load/refresh instead of restoring old scroll/hash position.
				if ('scrollRestoration' in history) {
					history.scrollRestoration = 'manual';
				}
				window.addEventListener('DOMContentLoaded', () => {
					if (window.location.hash) {
						history.replaceState(null, '', window.location.pathname + window.location.search);
					}
					window.scrollTo(0, 0);
				});

				// Add task file paths here as you create them (e.g. 'tasks/task2.html', 'tasks/task3.html')
				const taskFiles = [
					'task1.html',
				'task2.html',
				'task3.html', 
				'task4.html', 
				'task5.html',
				'task6.html'
			];

			const container = document.getElementById('tasks-container');
			const taskNav = document.getElementById('task-nav');

			function slugify(text) {
				return text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
			}

			function buildTaskSidebar() {
				taskNav.innerHTML = '';
				const headings = container.querySelectorAll('h2');
				headings.forEach((heading, index) => {
					if (!/^Task\s+\d+/i.test(heading.textContent.trim())) return;

					const headingId = heading.id || `task-${index + 1}-${slugify(heading.textContent)}`;
					heading.id = headingId;

					const li = document.createElement('li');
					const link = document.createElement('a');
					link.href = `#${headingId}`;
					link.textContent = heading.textContent.trim();
					link.dataset.targetId = headingId;
					li.appendChild(link);
					taskNav.appendChild(li);
				});
			}

			function setupTaskScrollSpy() {
				const links = Array.from(taskNav.querySelectorAll('a'));
				const sections = links
					.map(link => document.getElementById(link.dataset.targetId))
					.filter(Boolean);

				if (links.length === 0 || sections.length === 0) return;

				function setActive(id) {
					links.forEach(link => {
						link.classList.toggle('active', link.dataset.targetId === id);
					});
				}

				links.forEach(link => {
					link.addEventListener('click', () => {
						setActive(link.dataset.targetId);
					});
				});

				const observer = new IntersectionObserver(
					(entries) => {
						const visible = entries
							.filter(entry => entry.isIntersecting)
							.sort((a, b) => b.intersectionRatio - a.intersectionRatio);

						if (visible.length > 0) {
							setActive(visible[0].target.id);
						}
					},
					{
						root: null,
						threshold: [0.2, 0.4, 0.6],
						rootMargin: '-20% 0px -55% 0px',
					}
				);

				sections.forEach(section => observer.observe(section));
				setActive(sections[0].id);
			}

			Promise.all(taskFiles.map(file => fetch(file).then(r => r.text())))
				.then(contents => {
					contents.forEach(html => {
						const div = document.createElement('div');
						div.innerHTML = html;
						container.appendChild(div);
					});
					buildTaskSidebar();
					setupTaskScrollSpy();
					if (window.MathJax && MathJax.Hub) {
						MathJax.Hub.Queue(["Typeset", MathJax.Hub, container]);
					}
				})
				.catch(err => console.error('Failed to load task files:', err));
		</script>
	</body>
</html>
